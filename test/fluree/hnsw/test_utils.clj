(ns fluree.hnsw.test-utils
  (:require [clojure.edn :as edn]
            [clojure.java.io :as io]
            [clojure.set :as set]
            [clojure.string :as str]
            [clojure.test :refer :all]
            [fluree.hnsw.db :as db]
            [fluree.hnsw.item :as item]))

;; embeddings prepared with all-MiniLM-L6-v2 transformer
(def query-embeddings
  {
   "AI use in digital devices" [-0.054667015, -0.019048877, -0.028730769, -0.066732, 0.018371359, -0.003156403, 0.08989398, 0.009143737, 0.05482188, 0.016962929, -0.025932426, -0.0022363546, 0.046336014, -0.026424466, 0.024027374, 0.023159428, 0.034592774, 0.008530066, -0.05173489, -0.04147605, 0.09352552, -0.04890546, -0.027301552, -0.049873486, -0.027628392, 0.03924095, 0.044582766, -0.076267965, 0.008671284, -0.018063065, 0.016036049, 0.020733735, 0.045350075, 0.031655792, -0.11024784, -0.0598999, -0.028722933, -0.011078995, 0.0298147, -0.088249475, -0.048901178, -0.07273994, 0.026892468, -0.007761551, 0.08020184, 0.07853468, -0.06376529, 0.060535856, -0.02223225, 0.037054025, -0.0714931, 0.028722007, 0.026515445, 0.009767769, -0.0055680755, 0.0094126165, 0.09392377, 0.03249757, 0.04912384, 0.004616914, 0.05327235, -0.051210687, 0.07093362, 0.032779172, 0.058177933, 0.02373487, -0.015529, -0.009876472, 0.035191063, -0.04042087, 0.021935355, 0.052776836, 0.040379163, 0.015213918, 0.040632606, -0.06477613, 0.009128088, -0.019958159, 0.06701338, -0.053644843, -0.0047555272, -0.07046574, -0.023354115, 0.04633268, 0.012233381, 0.052513078, -0.07123517, -0.0016206969, 0.04624786, -0.019489799, -0.008915939, 0.013332663, -0.014435433, -0.02396589, 0.05583787, -0.073324315, 0.012493744, -0.06991275, -0.04564261, 0.06334278, -0.0262461, -0.008399918, -0.06001934, -0.025108222, -0.038249284, -0.03148408, 0.076449655, -0.06678188, 0.05701718, -0.05217082, -0.04397826, -0.0034005728, -0.01601474, -0.02690799, 0.064085916, -0.032784432, 0.0020215195, 0.108619235, 0.046773843, -0.032356583, -0.08217647, -0.027221523, -0.06816626, 0.100274056, 0.016109014, -0.04420937, -0.06753013, -3.8067136E-33, -0.04436976, -0.015047713, -0.0260472, 0.010240393, 0.01369622, -0.08104519, -0.01174741, 0.02940701, 0.05834939, -0.047178153, -0.01776724, 0.05364686, -0.04762453, 0.067191124, 0.10953719, -0.030805293, 0.030775264, 0.022496013, -6.926432E-4, -0.030344067, 0.03149511, -0.09172003, 0.025615873, 0.01966751, 0.04231811, 0.03772387, 0.017532203, -0.003732766, 0.12337975, 0.01126946, -0.03355411, -0.011511535, -0.07334375, -0.066529326, 0.008419947, 0.041713767, -0.04980378, 0.052936263, -0.0077319513, 0.10843144, -0.047464296, -0.012223649, 0.05694763, -0.005421908, -0.106843494, -0.011081225, 0.011732033, -0.031022727, -0.07016593, -0.010757551, -0.04120999, 0.051546685, -0.046405096, -0.12470296, 0.08082727, -0.041246165, -0.005663204, 0.007831756, 0.04465423, -0.026878571, -0.0019106002, -0.0022140734, -0.015697638, 0.109611064, -0.014543523, 0.09197878, 0.12769987, 0.019244866, 0.029811872, 0.0065326137, -0.026617024, -0.0039048416, -0.0582834, -0.061096437, -0.04244524, 0.009506441, -0.009200575, -0.060699314, -0.03578186, -0.025003366, -0.043655023, -0.019059908, -0.052350443, 0.015439525, -7.667249E-6, -0.014411707, -0.07546449, -0.08508536, -0.05100018, 0.030398918, -0.091157414, -0.0064069387, -0.051424347, 0.025984684, -0.031945996, 6.9037233E-34, -0.13989247, 0.0033314999, -0.03168307, 0.020912144, 0.008342471, -0.04812277, -0.004666405, -0.009657982, 0.054135714, -0.014183968, -0.0753394, 0.00712022, -0.018593177, -0.018907426, -0.02717345, 0.03391711, -0.052932616, -0.017526224, 0.014566266, -0.016650908, 0.016785556, 0.036276788, -0.006874737, -0.038110495, 0.018994277, 0.032253694, -0.101041816, 0.050440855, -0.015571516, -0.0046388046, 0.028394852, -0.056281537, -0.0011190298, 0.049557038, 0.038379017, 0.034813512, 0.06714381, 0.00443323, -0.025629856, 6.483512E-4, 0.079620935, 0.024992203, -0.020991044, 0.023163255, -0.0073876763, -0.04024264, -0.06800195, 0.08563632, -0.026365938, 0.010547927, 0.06488548, 0.012269239, -0.023706248, -0.121184334, -0.100104414, 0.07798003, 0.0014222913, 0.041138925, 0.012263366, 0.042446893, -0.03596734, -0.100220345, -0.010754239, -0.012080937, -0.07560759, -0.009253104, 0.055744905, 0.08524412, -0.034082703, 0.038201075, 0.10685479, -0.003260533, 0.040080007, 0.032637008, -0.031109931, -0.056504443, -0.06739968, 0.007051622, -0.024031566, 0.0039353115, -0.042048223, -0.013168507, 0.037834182, 0.04075785, -0.0014308665, 0.08575047, 0.03334423, -0.060970124, -0.023677934, 0.0055080424, -0.035592128, 0.093796544, -0.02256837, 0.053066395, -0.14512317, -1.3603777E-8, 0.02305988, -0.0055758436, 0.16968623, -0.01926117, 0.03633823, -0.02588614, 0.008224543, -0.0018318198, -0.030485535, -0.06116392, 0.034793783, -0.042735204, -0.019972935, 0.021894429, 0.11824627, 0.08170782, 0.027355494, -0.0408811, -0.0024308965, -0.012961104, 0.16378114, 0.02192982, -0.042288292, 0.012841452, 0.026203148, -0.02063896, 0.016929394, -0.016852854, -0.10615367, 0.10809245, -0.028501926, 0.06460695, 0.048235793, 0.057175137, 0.079192095, 0.010605433, 0.044733193, -0.060078688, -0.032021575, -0.018850682, -0.04798477, 0.01100723, -0.061435092, -2.1752703E-4, 0.016671048, -0.048089217, 0.028213093, -0.11667156, 0.017802818, 0.06989112, -0.04142731, 0.027640894, -0.0069732144, 0.110291265, 0.113842696, -0.0022288193, 0.07387512, -0.06803272, -0.03757677, 0.107383385, 0.02205331, 0.061504833, 0.043491982, -0.04727407]
   })

(defn flat-rank
  "Provides a flat-rank (100% recall ranking) of all the vectors in
  the provided db against the query."
  [db {:keys [vector top-k]}]
  (let [query-vector  (item/create {:values vector} (db/metric db) (db/t db))
        all-vectors   (-> db :layers first vals)
        reverse-sort? (item/reverse-sort? (first all-vectors))
        results       (->> all-vectors
                           (map (fn [vector-item]
                                  (assoc vector-item :score (item/dist vector-item query-vector))))
                           (map #(select-keys % [:id :score :t]))
                           (sort-by :score))]
    (cond->> results
             reverse-sort? reverse
             true (take top-k))))

(defn measure-recall
  "Given a reference result set (from a flat-rank that has 100% accuracy)
  Measure the recall rate of the query result set.

  Returns float > 0.0 and <= 1.0."
  [reference-result query-result]
  (let [n      (count reference-result)
        common (set/intersection (set (map :id reference-result))
                                 (set (map :id query-result)))]
    (float (/ (count common) n))))

(defn small-articles-dataset
  "35 news articles in edn with embeddings created by MiniLM-L6-v2
  on the summary."
  []
  (-> (io/resource "articles-all-MiniLM-L6-v2.edn")
      slurp
      edn/read-string))

(defn small-articles-vectors
  "Returns the small-articles-dataset as transactions for the HNSW index."
  []
  (let [articles (small-articles-dataset)]
    (map
     (fn [{:keys [id summary-embedding]}]
       {:id id :values summary-embedding})
     articles)))

(defn large-articles-dataset
  "Large articles file is 209527 news articles in edn with embeddings created by MiniLM-L6-v2
  for the article summary.

  The entire file is streamed, as it is too large to read into memory at once. Some
  special logic omits the open/close vectors [] in the file to parse each map individually."
  ([] (large-articles-dataset nil nil))
  ([limit offset]
   (let [files            ["010000.edn" "020000.edn" "030000.edn" "040000.edn" "050000.edn"
                           "060000.edn" "070000.edn" "080000.edn" "090000.edn" "100000.edn"
                           "110000.edn" "120000.edn" "130000.edn" "140000.edn" "150000.edn"
                           "160000.edn" "170000.edn" "180000.edn" "190000.edn" "200000.edn" "209527.edn"]
         ;; most of the time we are grabbing from the first file, so check and only parse that if needed (for speed)
         first-file-total (Integer/parseInt (re-find #"\d+" (first files)))
         first-file-only? (if (and limit offset)
                            (< (+ limit offset) first-file-total)
                            (if limit
                              (< limit first-file-total)))]
     (cond->> files
              first-file-only? (take 1)
              true (mapcat #(edn/read-string (slurp (str "test-resources/200K-news-dataset-all-MiniLM-L6-v2/" %))))
              offset (drop offset)
              limit (take limit)))))

(defn large-articles-vectors
  "Returns a vector of maps with :id and :values keys for `upsert` operation
  from the large-articles-dataset.

  Loading the full vector set takes ~ 20 seconds, use offset & limit for faster
  processing as applicable."
  ([] (large-articles-vectors nil nil))
  ([limit] (large-articles-vectors limit nil))
  ([limit offset]
   (let [ds (large-articles-dataset limit offset)]
     (mapv (fn [{:keys [id summary-embedding]}]
             {:id id :values (vec summary-embedding)})
           ds))))

